package jenkins.plugins.xclient;

import hudson.*;
import hudson.model.*;
import hudson.tasks.*;
import hudson.util.ArgumentListBuilder;
import hudson.util.StreamTaskListener;
import jenkins.tasks.SimpleBuildStep;
import org.apache.hc.core5.http.NameValuePair;
import org.kohsuke.stapler.*;

import java.io.*;
import java.util.*;
import java.util.regex.Pattern;

/**
 * {@link Publisher} that invokes X-Developer analysis service when building is completed.
 *
 * <p>
 *     This is a publisher of Jenkins. Plugins that retrieves Git log and sends to X-Developer analysis server directly during the building process in a Jenkins job or pipeline.
 * </p>
 *
 * <h2>Techniques</h2>
 * <p>
 *     User identity in Jenkins is global, and not specific to a particular job. As a result, log publisher resolution only receives {@link Configuration}, which by itself doesn't really have that much information in it.
 * </p>
 *
 * @author Chen Jiaxing
 * @since 2020/3/29
 */
public class LogPublisher extends Publisher implements SimpleBuildStep {

    /**
     * The unique id to use for identify the team.
     *
     * <p>
     *     Then a team is created, this id is generated by X-Developer, which is shown in API page. See https://x-developer.cn/accounts/api
     * </p>
     */
    private String teamId;

    /**
     * It true, the status of the issues are updated to released.
     */
    private boolean master;

    /**
     * If true, log analysis will be started immediately, otherwise, it runs during 5 p.m.~8 p.m everyday.
     */
    private boolean forceAnalysis;

    /**
     * Default Constructor.
     */
    @Deprecated
    public LogPublisher() {}

    /**
     * @param teamId single unique id of the given team
     */
    public LogPublisher(String teamId) {
        this(teamId, false, false);
    }

    /**
     * @param teamId single unique id of the given team
     * @param master if {@code true} the status of the issues are updated to released
     * @param forceAnalysis if {@code true} log analysis will be started immediately
     */
    @DataBoundConstructor
    public LogPublisher(String teamId, boolean master, boolean forceAnalysis) {
        this.teamId = teamId;
        this.master = master;
        this.forceAnalysis = forceAnalysis;
    }


    public String getTeamId() { return this.teamId; }

    public boolean getMaster() { return this.master; }

    public boolean getForceAnalysis() { return this.forceAnalysis; }

    /**
     * Together with {@link #getTeamId}, binds to entry in {@code config.jelly}.
     * @param teamId The unique id to use for identify the team.
     */
    @DataBoundSetter
    public void setTeamId(String teamId) { this.teamId = teamId; }

    /**
     * Together with {@link #getMaster}, binds to entry in {@code config.jelly}.
     * @param master If true, the status of the issues are updated to released
     */
    @DataBoundSetter
    public void setMaster(boolean master) { this.master = master; }

    /**
     * Together with {@link #getForceAnalysis} , binds to entry in {@code config.jelly}.
     * @param forceAnalysis If true, log analysis will be started immediately
     */
    @DataBoundSetter
    public void setForceAnalysis(boolean forceAnalysis) { this.forceAnalysis = forceAnalysis; }

    @Override
    public void perform(Run<?, ?> build, FilePath workspace, Launcher launcher, TaskListener listener) throws InterruptedException, IOException {
        String logFile = workspace.getName() + ".csv";
        String logFilePath = workspace.getRemote() + "/" + logFile;
        File file = new File(logFilePath);
        if (file.exists()) {
            boolean result = file.delete();
            if (result) {
                listener.getLogger().println(Messages.LogPublisher_Git_logDeleted());
            } else {
                listener.getLogger().println(Messages.LogPublisher_Git_errors_logDeletedFailed());
            }
        }
        String command = "git log --pretty=format:%an,%ae,%ai,%s";
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        StreamTaskListener taskListener = new StreamTaskListener(out);
        ArgumentListBuilder builder = new ArgumentListBuilder();
        builder.addTokenized(command);
        Launcher.ProcStarter starter = launcher.launch();
        starter = starter.cmds(builder).stdout(taskListener);
        starter = starter.pwd(workspace).envs(build.getEnvironment(taskListener));
        Proc proc = launcher.launch(starter);
        proc.join();
        FileOutputStream fileOut = null;
        try {
            fileOut = new FileOutputStream(logFilePath);
            fileOut.write(out.toByteArray());
        } catch (FileNotFoundException e) {
            listener.getLogger().println(e.getMessage());
        } catch (IOException e) {
            listener.getLogger().println(e.getMessage());
        } finally {
            if (fileOut != null) {
                fileOut.close();
            }
        }
        listener.getLogger().println(Messages.LogPublisher_Git_logGenerated());
        final String commandLine = "git log --pretty=format:\"%at\" -1";
        String lastCommit;
        out = new ByteArrayOutputStream();
        taskListener = new StreamTaskListener(out);
        builder = new ArgumentListBuilder();
        builder.addTokenized(commandLine);
        starter = launcher.launch();
        starter = starter.cmds(builder).stdout(taskListener);
        starter = starter.pwd(workspace).envs(build.getEnvironment(taskListener));
        proc = launcher.launch(starter);
        proc.join();
        lastCommit = out.toString("utf-8");
        if (test) {
            lastCommit = "1585572510";
        }
        Pattern pattern = Pattern.compile("[0-9]*");
        if (lastCommit == null || !pattern.matcher(lastCommit).matches()) {
            listener.getLogger().println(Messages.LogPublisher_Git_errors_logUpdateFailed());
            if (!test) {
                build.setResult(Result.UNSTABLE);
            }
        } else {
            List<NameValuePair> params = LogHttpClient.buildUpdateParameters(
                    teamId,
                    logFile,
                    logFilePath,
                    lastCommit,
                    master,
                    forceAnalysis
            );
            LogHttpClient client = new LogHttpClient();
            boolean result = client.updateStatus(params, listener);

            if (result) {
                build.setResult(Result.SUCCESS);
            } else {
                listener.getLogger().println(Messages.LogHttpClient_Response_analysisFailed());
                if (!test) {
                    build.setResult(Result.UNSTABLE);
                }
            }
        }
    }

    @Override
    public BuildStepMonitor getRequiredMonitorService() {
        return BuildStepMonitor.NONE;
    }

    @Extension
    public static final class DescriptorImpl extends BuildStepDescriptor<Publisher> {

        @Override
        public boolean isApplicable(Class<? extends AbstractProject> aClass) {
            return true;
        }

        @Override
        public String getDisplayName() {
            return Messages.LogPublisher_DescriptorImpl_DisplayName();
        }
    }

    public static final boolean test = false;
}
